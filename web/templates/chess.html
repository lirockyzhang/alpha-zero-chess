<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AlphaZero Chess</title>

    <!-- Chessboard.js CSS -->
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }

        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .model-info {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .model-info span {
            margin: 0 15px;
            color: #34495e;
            font-weight: 500;
        }

        .game-container {
            display: grid;
            grid-template-columns: 320px 1fr 340px;
            gap: 30px;
            margin-top: 20px;
        }

        .eval-panel {
            display: flex;
            flex-direction: column;
            position: sticky;
            top: 20px;
            align-self: start;
        }

        .board-column {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .control-group h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        button {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #7f8c8d;
        }

        .btn-stop {
            background: #e74c3c;
            color: white;
        }

        .btn-stop:hover:not(:disabled) {
            background: #c0392b;
        }

        .speed-slider {
            width: 100%;
            margin: 8px 0;
        }

        .speed-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.85em;
            color: #7f8c8d;
        }

        .status {
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
            width: 100%;
            max-width: 500px;
        }

        .move-history-group {
            width: 100%;
            max-width: 500px;
        }

        .status.info { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.warning { background: #fff3cd; color: #856404; }
        .status.error { background: #f8d7da; color: #721c24; }

        .move-history {
            max-height: 200px;
            overflow-y: auto;
            background: white;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .move-history p { margin: 5px 0; color: #34495e; }

        /* AI Evaluation Display */
        .ai-evaluation {
            background: white;
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .eval-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .eval-label { font-weight: 600; color: #2c3e50; }

        .eval-score { font-size: 1.2em; font-weight: bold; }
        .eval-score.positive { color: #27ae60; }
        .eval-score.negative { color: #e74c3c; }
        .eval-score.neutral { color: #95a5a6; }

        /* WDL Probability Bar */
        .wdl-container { margin-bottom: 10px; }
        .wdl-label { font-weight: 600; color: #2c3e50; margin-bottom: 6px; font-size: 0.9em; }

        .wdl-bar {
            display: flex;
            width: 100%;
            height: 26px;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #ddd;
        }

        .wdl-segment {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: 700;
            color: white;
            min-width: 28px;
            transition: width 0.4s ease;
            white-space: nowrap;
            overflow: hidden;
        }

        .wdl-win { background: #27ae60; }
        .wdl-draw { background: #95a5a6; }
        .wdl-loss { background: #e74c3c; }

        .top-moves { margin-top: 10px; }

        .top-move {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            margin: 3px 0;
            background: #f8f9fa;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .move-san { font-weight: 600; color: #2c3e50; }
        .move-prob { color: #7f8c8d; }

        /* Promotion Dialog */
        .promotion-dialog {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .promotion-dialog.active { display: flex; }

        .promotion-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .promotion-content h2 { margin-bottom: 20px; color: #2c3e50; }

        .promotion-pieces { display: flex; gap: 15px; justify-content: center; }

        .promotion-piece {
            width: 80px; height: 80px;
            border: 2px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 50px;
            transition: all 0.3s;
        }

        .promotion-piece:hover {
            border-color: #3498db;
            background: #ebf5fb;
            transform: scale(1.1);
        }

        /* PGN Buttons */
        .btn-pgn { background: #2ecc71; color: white; }
        .btn-pgn:hover:not(:disabled) { background: #27ae60; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3); }

        .btn-import { background: #9b59b6; color: white; }
        .btn-import:hover:not(:disabled) { background: #8e44ad; transform: translateY(-2px); box-shadow: 0 5px 15px rgba(155, 89, 182, 0.3); }

        .pgn-buttons { display: flex; gap: 10px; }
        .pgn-buttons button { flex: 1; }

        /* Replay Mode Controls */
        .replay-controls { display: none; margin-top: 10px; }
        .replay-controls.active { display: block; }

        .replay-nav { display: flex; gap: 5px; margin-bottom: 10px; }
        .replay-nav button { flex: 1; padding: 8px; font-size: 1.1em; margin-bottom: 0; }

        .btn-replay-nav { background: #34495e; color: white; }
        .btn-replay-nav:hover { background: #2c3e50; }
        .btn-exit-replay { background: #e74c3c; color: white; }
        .btn-exit-replay:hover { background: #c0392b; }
        .replay-info { text-align: center; font-size: 0.9em; color: #7f8c8d; margin-bottom: 8px; }
        .move-history .replay-active { background: #3498db; color: white; border-radius: 3px; padding: 1px 4px; }

        /* Auto-play button for replay */
        .btn-autoplay { background: #2ecc71; color: white; }
        .btn-autoplay:hover { background: #27ae60; }
        .btn-autoplay.playing { background: #e67e22; }
        .btn-autoplay.playing:hover { background: #d35400; }

        /* Player selector dropdown */
        .player-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
        }

        .player-row label {
            font-weight: 600;
            color: #2c3e50;
            min-width: 50px;
        }

        .player-row select {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.95em;
            background: white;
        }

        /* Collapsible sub-panels */
        .sub-panel {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .sub-panel h4 {
            color: #34495e;
            font-size: 0.95em;
            margin-bottom: 10px;
        }

        .sub-panel label {
            font-weight: 500;
            color: #34495e;
            display: block;
            margin-bottom: 4px;
            font-size: 0.9em;
        }

        .sub-panel select,
        .sub-panel input[type="number"],
        .sub-panel input[type="text"] {
            width: 100%;
            padding: 7px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .btn-load-model {
            background: #8e44ad;
            color: white;
        }

        .btn-load-model:hover:not(:disabled) {
            background: #7d3c98;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(142, 68, 173, 0.3);
        }

        .model-status {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .model-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .model-status-dot.loaded {
            background: #27ae60;
            box-shadow: 0 0 6px rgba(39, 174, 96, 0.5);
        }

        .model-status-dot.not-loaded {
            background: #e74c3c;
            box-shadow: 0 0 6px rgba(231, 76, 60, 0.5);
        }

        .model-status-text {
            font-size: 0.85em;
            color: #34495e;
        }

        /* In-game controls */
        .ingame-controls {
            display: none;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid #ddd;
        }

        .ingame-controls.active { display: block; }

        .ingame-btn-row {
            display: flex;
            gap: 8px;
        }

        .ingame-btn-row button { flex: 1; }

        .btn-pause { background: #f39c12; color: white; }
        .btn-pause:hover:not(:disabled) { background: #e67e22; }
        .btn-resume { background: #27ae60; color: white; }
        .btn-resume:hover:not(:disabled) { background: #219a52; }

        /* Checkbox row */
        .checkbox-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .checkbox-row input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        .checkbox-row label {
            margin-bottom: 0;
            font-size: 0.9em;
        }

        @media (max-width: 1024px) {
            .game-container {
                grid-template-columns: 320px 1fr;
            }
            .controls {
                grid-column: 1 / -1;
            }
        }

        @media (max-width: 768px) {
            .game-container {
                grid-template-columns: 1fr;
            }
            .eval-panel {
                position: static;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>AlphaZero Chess</h1>
        <p class="subtitle">Play against AI, watch AI vs AI, or test with Stockfish</p>

        <div class="model-info" id="model-info-banner">
            <span id="model-info-text">
                {% if model_loaded %}
                    {% if white_model.loaded and black_model.loaded and white_model.name == black_model.name %}
                        {{ white_model.name }} -- {{ white_model.num_filters }}f/{{ white_model.num_blocks }}b
                    {% elif white_model.loaded and black_model.loaded %}
                        W: {{ white_model.name }} ({{ white_model.num_filters }}f/{{ white_model.num_blocks }}b) vs B: {{ black_model.name }} ({{ black_model.num_filters }}f/{{ black_model.num_blocks }}b)
                    {% elif white_model.loaded %}
                        White: {{ white_model.name }} ({{ white_model.num_filters }}f/{{ white_model.num_blocks }}b)
                    {% else %}
                        Black: {{ black_model.name }} ({{ black_model.num_filters }}f/{{ black_model.num_blocks }}b)
                    {% endif %}
                {% else %}
                    No model loaded -- load a checkpoint to start playing
                {% endif %}
            </span>
        </div>

        <div class="game-container">
            <!-- Left column: AI Evaluation -->
            <div class="eval-panel">
                <div class="control-group">
                    <h3 id="eval-panel-title">AI Evaluation</h3>
                    <div class="ai-evaluation" id="ai-evaluation">
                        <div class="eval-value">
                            <span class="eval-label" id="eval-value-label">MCTS Value:</span>
                            <span class="eval-score neutral" id="mcts-score">--</span>
                        </div>
                        <div class="wdl-container" id="wdl-container">
                            <div class="wdl-label">Win / Draw / Loss</div>
                            <div class="wdl-bar">
                                <div class="wdl-segment wdl-win" id="wdl-win" style="width:33.3%">--</div>
                                <div class="wdl-segment wdl-draw" id="wdl-draw" style="width:33.3%">--</div>
                                <div class="wdl-segment wdl-loss" id="wdl-loss" style="width:33.3%">--</div>
                            </div>
                        </div>
                        <!-- Fallback for legacy scalar models -->
                        <div class="eval-value" id="nn-value-fallback" style="display:none;">
                            <span class="eval-label">NN Value:</span>
                            <span class="eval-score neutral" id="nn-score">--</span>
                        </div>
                        <div class="top-moves" id="top-moves">
                            <p style="color: #95a5a6; font-size: 0.9em;">No evaluation yet</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Center column: Board + Status + Move History -->
            <div class="board-column">
                <div id="board"></div>
                <div id="status" class="status info">Configure players and click "Start Game"</div>
                <div class="move-history-group">
                    <div class="control-group">
                        <h3>Move History</h3>
                        <div class="move-history" id="move-history">
                            <p style="color: #95a5a6;">No moves yet</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right column: Unified Controls -->
            <div class="controls">
                <!-- Game Setup Panel -->
                <div class="control-group" id="setup-panel">
                    <h3>Game Setup</h3>

                    <div class="player-row">
                        <label for="white-player">White:</label>
                        <select id="white-player" onchange="onPlayerTypeChange()">
                            <option value="human">Human</option>
                            <option value="model">AlphaZero Model</option>
                            <option value="stockfish" id="white-sf-option">Stockfish</option>
                        </select>
                    </div>

                    <div class="player-row">
                        <label for="black-player">Black:</label>
                        <select id="black-player" onchange="onPlayerTypeChange()">
                            <option value="human">Human</option>
                            <option value="model" selected>AlphaZero Model</option>
                            <option value="stockfish" id="black-sf-option">Stockfish</option>
                        </select>
                    </div>

                    <!-- White Checkpoint Picker (shown when white is model) -->
                    <div class="sub-panel" id="checkpoint-panel-white" style="display:none;">
                        <h4>White Checkpoint</h4>
                        <div class="model-status" id="model-status-white">
                            <div class="model-status-dot {{ 'loaded' if white_model.loaded else 'not-loaded' }}" id="model-status-dot-white"></div>
                            <span class="model-status-text" id="model-status-text-white">
                                {% if white_model.loaded %}Loaded: {{ white_model.name }}{% else %}Not loaded{% endif %}
                            </span>
                        </div>
                        <select id="checkpoint-select-white">
                            <option value="">-- Select checkpoint --</option>
                        </select>
                        <input type="text" id="model-path-input-white" placeholder="Or enter path manually..."
                               style="margin-bottom: 8px;">
                        <button class="btn-load-model" onclick="loadCheckpoint('white')">Load</button>
                    </div>

                    <!-- Black Checkpoint Picker (shown when black is model) -->
                    <div class="sub-panel" id="checkpoint-panel-black" style="display:none;">
                        <h4>Black Checkpoint</h4>
                        <div class="model-status" id="model-status-black">
                            <div class="model-status-dot {{ 'loaded' if black_model.loaded else 'not-loaded' }}" id="model-status-dot-black"></div>
                            <span class="model-status-text" id="model-status-text-black">
                                {% if black_model.loaded %}Loaded: {{ black_model.name }}{% else %}Not loaded{% endif %}
                            </span>
                        </div>
                        <select id="checkpoint-select-black">
                            <option value="">-- Select checkpoint --</option>
                        </select>
                        <input type="text" id="model-path-input-black" placeholder="Or enter path manually..."
                               style="margin-bottom: 8px;">
                        <button class="btn-load-model" onclick="loadCheckpoint('black')">Load</button>
                    </div>

                    <!-- Stockfish Settings (shown when stockfish selected) -->
                    <div class="sub-panel" id="stockfish-panel" style="display:none;">
                        <h4>Stockfish Settings</h4>
                        <label for="sf-depth">Depth:</label>
                        <input type="number" id="sf-depth" value="20" min="1" max="30">
                        <div class="checkbox-row">
                            <input type="checkbox" id="sf-limit-elo" onchange="document.getElementById('sf-elo').disabled = !this.checked;">
                            <label for="sf-limit-elo">Limit ELO:</label>
                        </div>
                        <input type="number" id="sf-elo" value="1500" min="100" max="3500" disabled>
                    </div>

                    <button class="btn-primary" id="start-game-btn" onclick="startGame()">Start Game</button>

                    <!-- In-Game Controls (shown during game) -->
                    <div class="ingame-controls" id="ingame-controls">
                        <div class="ingame-btn-row">
                            <button class="btn-pause" id="pause-btn" onclick="pauseGame()">Pause</button>
                            <button class="btn-resume" id="resume-btn" onclick="resumeGame()" style="display:none;">Resume</button>
                            <button class="btn-secondary" id="new-setup-btn" onclick="newSetup()">New Setup</button>
                        </div>
                        <div id="delay-slider-container" style="margin-top: 8px;">
                            <label for="speed-slider" style="font-weight: 500; color: #34495e; display: block; margin-bottom: 4px;">Move Delay</label>
                            <input type="range" id="speed-slider" class="speed-slider" min="0.1" max="3.0" step="0.1" value="0.8">
                            <div class="speed-label">
                                <span>Fast (0.1s)</span>
                                <span id="speed-value">0.8s</span>
                                <span>Slow (3s)</span>
                            </div>
                        </div>
                    </div>

                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
                        <div class="pgn-buttons">
                            <button class="btn-pgn" onclick="exportPGN()">Export PGN</button>
                            <button class="btn-import" onclick="document.getElementById('pgn-file-input').click()">Import PGN</button>
                        </div>
                        <input type="file" id="pgn-file-input" accept=".pgn" style="display: none;" onchange="importPGN(event)">
                    </div>

                    <div class="replay-controls" id="replay-controls">
                        <div class="replay-info" id="replay-info">Replay Mode</div>
                        <div class="replay-nav">
                            <button class="btn-replay-nav" onclick="replayStep('first')" title="First move">|&#9665;</button>
                            <button class="btn-replay-nav" onclick="replayStep('prev')" title="Previous move">&#9665;</button>
                            <button class="btn-replay-nav btn-autoplay" id="autoplay-btn" onclick="toggleReplayAutoPlay()" title="Auto-play">&#9654;</button>
                            <button class="btn-replay-nav" onclick="replayStep('next')" title="Next move">&#9655;</button>
                            <button class="btn-replay-nav" onclick="replayStep('last')" title="Last move">&#9655;|</button>
                        </div>
                        <button class="btn-exit-replay" onclick="exitReplay()">Exit Replay</button>
                    </div>
                </div>

                <!-- MCTS Settings -->
                <div class="control-group">
                    <h3>MCTS Settings</h3>
                    <div style="margin-bottom: 10px;">
                        <label for="sim-input" style="font-weight: 500; color: #34495e; display: block; margin-bottom: 4px;">Simulations</label>
                        <input type="number" id="sim-input" value="{{ num_simulations }}" min="1" max="100000" step="100"
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;"
                               onchange="updateSettings()">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label for="cpuct-input" style="font-weight: 500; color: #34495e; display: block; margin-bottom: 4px;">C_PUCT (exploration)</label>
                        <input type="number" id="cpuct-input" value="{{ c_puct }}" min="0.01" max="100" step="0.25"
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;"
                               onchange="updateSettings()">
                    </div>
                    <div>
                        <label for="risk-beta-input" style="font-weight: 500; color: #34495e; display: block; margin-bottom: 4px;"
                               title="Entropic Risk Measure: >0 risk-seeking (sharp play), <0 risk-averse (safe play), 0 standard">Risk Beta (ERM)</label>
                        <input type="number" id="risk-beta-input" value="{{ risk_beta }}" min="-3" max="3" step="0.1"
                               style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 6px; font-size: 1em;"
                               onchange="updateSettings()">
                        <div style="font-size: 0.75em; color: #95a5a6; margin-top: 2px;">-3 safe ... 0 neutral ... +3 aggressive</div>
                    </div>
                    <div id="settings-status" style="margin-top: 8px; font-size: 0.85em; color: #7f8c8d;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Promotion Dialog -->
    <div class="promotion-dialog" id="promotion-dialog">
        <div class="promotion-content">
            <h2>Choose Promotion Piece</h2>
            <div class="promotion-pieces">
                <div class="promotion-piece" onclick="selectPromotion('q')">&#9813;</div>
                <div class="promotion-piece" onclick="selectPromotion('r')">&#9814;</div>
                <div class="promotion-piece" onclick="selectPromotion('b')">&#9815;</div>
                <div class="promotion-piece" onclick="selectPromotion('n')">&#9816;</div>
            </div>
        </div>
    </div>

    <!-- jQuery -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <!-- Chess.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <!-- Chessboard.js -->
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>

    <script>
        // ===================== State =====================
        let board = null;
        let game = new Chess();
        let sessionId = 'session_' + Date.now();
        let moveHistory = [];
        let pendingMove = null;

        // Game config — replaces old humanColor + selfPlayActive
        let gameConfig = { white: 'human', black: 'model' };
        let gameActive = false;     // true while a game is in progress
        let aiTurnActive = false;   // true while AI polling loop is running
        let gamePaused = false;
        let aiTimeout = null;

        let modelStatus = {
            white: { loaded: {{ 'true' if white_model.loaded else 'false' }}, name: '{{ white_model.name }}', filters: {{ white_model.num_filters }}, blocks: {{ white_model.num_blocks }} },
            black: { loaded: {{ 'true' if black_model.loaded else 'false' }}, name: '{{ black_model.name }}', filters: {{ black_model.num_filters }}, blocks: {{ black_model.num_blocks }} }
        };
        let stockfishAvailable = {{ 'true' if stockfish_available else 'false' }};

        // Replay state
        let replayMode = false;
        let replayGame = null;
        let replayMoves = [];
        let replayIndex = -1;
        let replayAutoPlay = false;
        let replayAutoPlayTimeout = null;

        // ===================== Helpers =====================

        function parseUciMove(uci) {
            return {
                from: uci.substring(0, 2),
                to: uci.substring(2, 4),
                promotion: uci.length > 4 ? uci[4] : undefined
            };
        }

        function updateStatus(message, type = 'info') {
            const el = document.getElementById('status');
            el.textContent = message;
            el.className = 'status ' + type;
        }

        function updateMoveHistory() {
            const el = document.getElementById('move-history');
            if (moveHistory.length === 0) {
                el.innerHTML = '<p style="color: #95a5a6;">No moves yet</p>';
                return;
            }
            let html = '';
            for (let i = 0; i < moveHistory.length; i += 2) {
                const num = Math.floor(i / 2) + 1;
                html += `<p>${num}. ${moveHistory[i]} ${moveHistory[i + 1] || ''}</p>`;
            }
            el.innerHTML = html;
            el.scrollTop = el.scrollHeight;
        }

        function colorEvalScore(el, value) {
            el.textContent = value.toFixed(3);
            el.className = value > 0.1 ? 'eval-score positive' : value < -0.1 ? 'eval-score negative' : 'eval-score neutral';
        }

        function resetEvalDisplay() {
            document.getElementById('eval-value-label').textContent = 'MCTS Value:';
            document.getElementById('mcts-score').textContent = '--';
            document.getElementById('mcts-score').className = 'eval-score neutral';
            document.getElementById('wdl-container').style.display = '';
            document.getElementById('nn-value-fallback').style.display = 'none';
            ['wdl-win', 'wdl-draw', 'wdl-loss'].forEach(id => {
                document.getElementById(id).style.width = '33.3%';
                document.getElementById(id).textContent = '--';
            });
            document.getElementById('top-moves').innerHTML = '<p style="color: #95a5a6; font-size: 0.9em;">No evaluation yet</p>';
        }

        /** Determine which player is to move now */
        function currentPlayer() {
            return game.turn() === 'w' ? gameConfig.white : gameConfig.black;
        }

        /** Check if any side is an AI (model or stockfish) */
        function hasAI() {
            return gameConfig.white !== 'human' || gameConfig.black !== 'human';
        }

        /** Get the human's color, or null if none/both */
        function humanSide() {
            const wh = gameConfig.white === 'human';
            const bh = gameConfig.black === 'human';
            if (wh && !bh) return 'white';
            if (bh && !wh) return 'black';
            return null;  // both or neither
        }

        // ===================== Setup Panel =====================

        function initSetupPanel() {
            // Fetch checkpoints and populate both dropdowns
            fetch('/api/list_checkpoints')
                .then(r => r.json())
                .then(data => {
                    ['white', 'black'].forEach(slot => {
                        const sel = document.getElementById(`checkpoint-select-${slot}`);
                        (data.checkpoints || []).forEach(cp => {
                            const opt = document.createElement('option');
                            opt.value = cp.path;
                            opt.textContent = cp.display;
                            sel.appendChild(opt);
                        });
                    });
                })
                .catch(() => {});

            // Fetch stockfish status
            fetch('/api/stockfish_status')
                .then(r => r.json())
                .then(data => {
                    stockfishAvailable = data.available;
                    if (!data.available) {
                        document.getElementById('white-sf-option').textContent = 'Stockfish (not installed)';
                        document.getElementById('white-sf-option').disabled = true;
                        document.getElementById('black-sf-option').textContent = 'Stockfish (not installed)';
                        document.getElementById('black-sf-option').disabled = true;
                    }
                })
                .catch(() => {});

            // Fetch per-slot model status
            fetch('/api/model_status')
                .then(r => r.json())
                .then(data => {
                    updateSlotUI('white', data.white);
                    updateSlotUI('black', data.black);
                })
                .catch(() => {});

            onPlayerTypeChange();
        }

        function onPlayerTypeChange() {
            const wp = document.getElementById('white-player').value;
            const bp = document.getElementById('black-player').value;

            // Show/hide per-side checkpoint panels independently
            document.getElementById('checkpoint-panel-white').style.display = (wp === 'model') ? '' : 'none';
            document.getElementById('checkpoint-panel-black').style.display = (bp === 'model') ? '' : 'none';

            // Show/hide stockfish panel
            const needsSf = (wp === 'stockfish' || bp === 'stockfish');
            document.getElementById('stockfish-panel').style.display = needsSf ? '' : 'none';
        }

        // ===================== Start Game =====================

        function startGame() {
            if (replayMode) exitReplay();
            if (aiTurnActive) stopAI();

            const wp = document.getElementById('white-player').value;
            const bp = document.getElementById('black-player').value;

            // Validate per-slot model loading
            if (wp === 'model' && !modelStatus.white.loaded) {
                updateStatus('Load a model checkpoint for White first', 'error');
                return;
            }
            if (bp === 'model' && !modelStatus.black.loaded) {
                updateStatus('Load a model checkpoint for Black first', 'error');
                return;
            }
            if ((wp === 'stockfish' || bp === 'stockfish') && !stockfishAvailable) {
                updateStatus('Stockfish is not installed', 'error');
                return;
            }

            gameConfig = { white: wp, black: bp };
            updateStatus('Starting game...', 'info');

            // Build request
            const body = {
                session_id: sessionId,
                white_player: wp,
                black_player: bp,
            };

            if (wp === 'stockfish' || bp === 'stockfish') {
                body.stockfish_depth = parseInt(document.getElementById('sf-depth').value) || 20;
                if (document.getElementById('sf-limit-elo').checked) {
                    body.stockfish_elo = parseInt(document.getElementById('sf-elo').value) || 1500;
                }
            }

            fetch('/api/new_game', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    updateStatus('Error: ' + data.error, 'error');
                    return;
                }

                // Reset frontend
                game = new Chess();
                moveHistory = [];
                updateMoveHistory();
                resetEvalDisplay();

                // Board orientation
                const hs = humanSide();
                board.orientation(hs || 'white');
                board.position('start');

                gameActive = true;
                showIngameControls(true);

                // If White was AI, the server already made the first move
                if (data.ai_move) {
                    const aiMove = game.move(parseUciMove(data.ai_move));
                    if (aiMove) {
                        moveHistory.push(aiMove.san);
                        updateMoveHistory();
                    }
                    game.load(data.fen);
                    board.position(data.fen);
                    if (data.evaluation) updateEvaluation(data.evaluation);
                }

                // Determine what to show
                const cp = currentPlayer();
                if (cp === 'human') {
                    updateStatus('Your turn', 'info');
                } else {
                    // It's an AI's turn — start polling loop
                    startAILoop();
                }
            })
            .catch(err => {
                updateStatus('Error: ' + err.message, 'error');
            });
        }

        function showIngameControls(show) {
            const el = document.getElementById('ingame-controls');
            el.classList.toggle('active', show);

            // Show move delay only if any AI plays
            document.getElementById('delay-slider-container').style.display = hasAI() ? '' : 'none';

            // Reset pause/resume buttons
            document.getElementById('pause-btn').style.display = '';
            document.getElementById('resume-btn').style.display = 'none';
            gamePaused = false;
        }

        function newSetup() {
            stopAI();
            gameActive = false;
            showIngameControls(false);
            game = new Chess();
            board.position('start');
            moveHistory = [];
            updateMoveHistory();
            resetEvalDisplay();
            updateStatus('Configure players and click "Start Game"', 'info');
        }

        // ===================== AI Polling Loop =====================

        function startAILoop() {
            aiTurnActive = true;
            gamePaused = false;
            aiStep();
        }

        function aiStep() {
            if (!aiTurnActive || gamePaused) return;

            const turn = game.turn() === 'w' ? 'White' : 'Black';
            const engine = currentPlayer();
            const label = engine === 'stockfish' ? 'Stockfish' : 'AlphaZero';
            updateStatus(`${label} (${turn}) is thinking...`, 'info');

            fetch('/api/ai_move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId })
            })
            .then(r => r.json())
            .then(data => {
                if (!aiTurnActive) return;

                if (!data.success) {
                    updateStatus('Error: ' + data.error, 'error');
                    stopAI();
                    return;
                }

                if (data.waiting_for_human) {
                    // It's a human's turn now
                    aiTurnActive = false;
                    updateStatus('Your turn', 'info');
                    return;
                }

                // Apply AI move
                if (data.ai_move) {
                    const move = game.move(parseUciMove(data.ai_move));
                    if (move) {
                        moveHistory.push(move.san);
                        updateMoveHistory();
                    }
                }

                game.load(data.fen);
                board.position(data.fen, true);

                if (data.evaluation) updateEvaluation(data.evaluation);

                // Game over?
                if (data.game_over) {
                    const result = data.result;
                    let msg = 'Game Over! ';
                    if (result.winner === 'white') msg += 'White wins';
                    else if (result.winner === 'black') msg += 'Black wins';
                    else msg += 'Draw';
                    msg += ' (' + result.reason + ')';
                    updateStatus(msg, 'success');
                    stopAI();
                    return;
                }

                if (gamePaused) {
                    updateStatus('Game paused', 'warning');
                    return;
                }

                // If next player is also AI, schedule next step
                const nextPlayer = currentPlayer();
                if (nextPlayer !== 'human') {
                    const delay = parseFloat(document.getElementById('speed-slider').value) * 1000;
                    aiTimeout = setTimeout(aiStep, delay);
                } else {
                    // Hand control back to human
                    aiTurnActive = false;
                    updateStatus('Your turn', 'info');
                }
            })
            .catch(err => {
                if (aiTurnActive) {
                    updateStatus('Error: ' + err.message, 'error');
                    stopAI();
                }
            });
        }

        function stopAI() {
            aiTurnActive = false;
            gamePaused = false;
            if (aiTimeout) {
                clearTimeout(aiTimeout);
                aiTimeout = null;
            }
        }

        function pauseGame() {
            gamePaused = true;
            if (aiTimeout) {
                clearTimeout(aiTimeout);
                aiTimeout = null;
            }
            document.getElementById('pause-btn').style.display = 'none';
            document.getElementById('resume-btn').style.display = '';
            updateStatus('Game paused', 'warning');
        }

        function resumeGame() {
            gamePaused = false;
            document.getElementById('pause-btn').style.display = '';
            document.getElementById('resume-btn').style.display = 'none';

            // If it's an AI's turn, resume the polling loop
            if (currentPlayer() !== 'human') {
                aiTurnActive = true;
                aiStep();
            } else {
                updateStatus('Your turn', 'info');
            }
        }

        // ===================== Evaluation Display =====================

        function updateEvaluation(evaluation) {
            if (!evaluation) return;

            // Adapt labels for Stockfish vs Model
            const isStockfish = evaluation.engine === 'stockfish';
            document.getElementById('eval-value-label').textContent = isStockfish ? 'SF Eval:' : 'MCTS Value:';

            colorEvalScore(document.getElementById('mcts-score'), evaluation.mcts_value);

            // WDL bar
            if (evaluation.wdl) {
                const [win, draw, loss] = evaluation.wdl;
                document.getElementById('wdl-container').style.display = '';
                document.getElementById('nn-value-fallback').style.display = 'none';
                document.getElementById('wdl-win').style.width = (win * 100) + '%';
                document.getElementById('wdl-win').textContent = (win * 100).toFixed(1) + '%';
                document.getElementById('wdl-draw').style.width = (draw * 100) + '%';
                document.getElementById('wdl-draw').textContent = (draw * 100).toFixed(1) + '%';
                document.getElementById('wdl-loss').style.width = (loss * 100) + '%';
                document.getElementById('wdl-loss').textContent = (loss * 100).toFixed(1) + '%';
            } else {
                document.getElementById('wdl-container').style.display = 'none';
                document.getElementById('nn-value-fallback').style.display = '';
                colorEvalScore(document.getElementById('nn-score'), evaluation.nn_value);
            }

            // Top moves
            const topEl = document.getElementById('top-moves');
            if (evaluation.top_moves && evaluation.top_moves.length > 0) {
                const label = isStockfish ? 'Top Moves (cp):' : 'Top Moves:';
                let html = `<div style="font-size: 0.85em; color: #7f8c8d; margin-bottom: 5px;">${label}</div>`;
                evaluation.top_moves.forEach((m, idx) => {
                    let metric;
                    if (isStockfish) {
                        // Show centipawns
                        const cp = m.cp !== undefined ? m.cp : m.probability;
                        metric = (cp > 0 ? '+' : '') + Math.round(cp) + ' cp';
                    } else {
                        metric = (m.probability * 100).toFixed(1) + '%';
                    }
                    html += `<div class="top-move">
                        <span class="move-san">${idx + 1}. ${m.move_san}</span>
                        <span class="move-prob">${metric}</span>
                    </div>`;
                });
                topEl.innerHTML = html;
            } else {
                topEl.innerHTML = '<p style="color: #95a5a6; font-size: 0.9em;">No moves available</p>';
            }
        }

        // ===================== Board Interaction =====================

        function onDragStart(source, piece, position, orientation) {
            if (replayMode) return false;
            if (game.game_over()) return false;
            if (!gameActive) return false;

            // Check if current turn belongs to a human player
            const isWhiteTurn = game.turn() === 'w';
            const player = isWhiteTurn ? gameConfig.white : gameConfig.black;
            if (player !== 'human') return false;

            // Only let human drag their own color
            if (isWhiteTurn && piece.search(/^b/) !== -1) return false;
            if (!isWhiteTurn && piece.search(/^w/) !== -1) return false;
        }

        function onDrop(source, target) {
            const piece = game.get(source);
            const isPromotion = piece && piece.type === 'p' &&
                ((piece.color === 'w' && target[1] === '8') ||
                 (piece.color === 'b' && target[1] === '1'));

            if (isPromotion) {
                pendingMove = { from: source, to: target };
                document.getElementById('promotion-dialog').classList.add('active');
                return 'snapback';
            }

            const move = game.move({ from: source, to: target });
            if (move === null) return 'snapback';

            moveHistory.push(move.san);
            updateMoveHistory();
            makeMove(move.from + move.to);
        }

        function selectPromotion(piece) {
            document.getElementById('promotion-dialog').classList.remove('active');
            if (!pendingMove) return;

            const move = game.move({
                from: pendingMove.from,
                to: pendingMove.to,
                promotion: piece
            });

            if (move === null) {
                board.position(game.fen());
                pendingMove = null;
                return;
            }

            board.position(game.fen());
            moveHistory.push(move.san);
            updateMoveHistory();
            makeMove(move.from + move.to + piece);
            pendingMove = null;
        }

        function onSnapEnd() {
            board.position(game.fen());
        }

        function makeMove(moveUci) {
            const opponent = currentPlayer();  // after our local move, game.turn() flipped
            const isOpponentAI = (opponent !== 'human');

            if (isOpponentAI) {
                updateStatus('AI is thinking...', 'info');
            }

            fetch('/api/make_move', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId, move: moveUci })
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    updateStatus('Error: ' + data.error, 'error');
                    game.undo();
                    moveHistory.pop();
                    updateMoveHistory();
                    board.position(game.fen());
                    return;
                }

                // If AI auto-responded
                if (data.ai_move) {
                    const aiMove = game.move(parseUciMove(data.ai_move));
                    if (aiMove) {
                        moveHistory.push(aiMove.san);
                        updateMoveHistory();
                    }
                }

                game.load(data.fen);
                board.position(data.fen);

                if (data.evaluation) updateEvaluation(data.evaluation);

                if (data.game_over) {
                    const result = data.result;
                    const hs = humanSide();
                    let msg = 'Game Over! ';
                    if (result.winner === hs) msg += 'You won!';
                    else if (result.winner === null) msg += 'Draw';
                    else if (hs) msg += 'AI won!';
                    else msg += (result.winner === 'white' ? 'White' : 'Black') + ' wins';
                    msg += ' (' + result.reason + ')';
                    updateStatus(msg, result.winner === hs ? 'success' : 'warning');
                } else {
                    // Check if next turn is AI → start polling
                    const nextPlayer = currentPlayer();
                    if (nextPlayer !== 'human') {
                        startAILoop();
                    } else {
                        updateStatus('Your turn', 'info');
                    }
                }
            })
            .catch(err => {
                updateStatus('Error: ' + err.message, 'error');
                game.undo();
                moveHistory.pop();
                updateMoveHistory();
                board.position(game.fen());
            });
        }

        // ===================== Model Loading =====================

        /** Update UI for a single model slot (white or black). */
        function updateSlotUI(slot, info) {
            modelStatus[slot] = info;
            const dot = document.getElementById(`model-status-dot-${slot}`);
            const text = document.getElementById(`model-status-text-${slot}`);

            if (info.loaded) {
                dot.className = 'model-status-dot loaded';
                text.textContent = `Loaded: ${info.name} (${info.num_filters}f/${info.num_blocks}b)`;
            } else {
                dot.className = 'model-status-dot not-loaded';
                text.textContent = 'Not loaded';
            }
            updateBanner();
        }

        /** Update the top banner to reflect current model state. */
        function updateBanner() {
            const banner = document.getElementById('model-info-text');
            const w = modelStatus.white;
            const b = modelStatus.black;
            if (w.loaded && b.loaded && w.name === b.name) {
                banner.textContent = `${w.name} -- ${w.num_filters}f/${w.num_blocks}b`;
            } else if (w.loaded && b.loaded) {
                banner.textContent = `W: ${w.name} (${w.num_filters}f/${w.num_blocks}b) vs B: ${b.name} (${b.num_filters}f/${b.num_blocks}b)`;
            } else if (w.loaded) {
                banner.textContent = `White: ${w.name} (${w.num_filters}f/${w.num_blocks}b)`;
            } else if (b.loaded) {
                banner.textContent = `Black: ${b.name} (${b.num_filters}f/${b.num_blocks}b)`;
            } else {
                banner.textContent = 'No model loaded -- load a checkpoint to start playing';
            }
        }

        /** Load checkpoint for a specific slot ("white" or "black"). */
        function loadCheckpoint(slot) {
            const dropdown = document.getElementById(`checkpoint-select-${slot}`).value;
            const manual = document.getElementById(`model-path-input-${slot}`).value.trim();
            const path = manual || dropdown;

            if (!path) {
                updateStatus(`Select a checkpoint or enter a path for ${slot}`, 'error');
                return;
            }

            updateStatus(`Loading ${slot} model...`, 'info');
            document.getElementById(`model-status-text-${slot}`).textContent = 'Loading...';

            fetch('/api/load_model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ checkpoint_path: path, slot: slot })
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    updateSlotUI('white', data.white);
                    updateSlotUI('black', data.black);
                    updateStatus(`${slot.charAt(0).toUpperCase() + slot.slice(1)} model loaded: ${data.model_name}`, 'success');
                } else {
                    updateStatus('Failed: ' + data.error, 'error');
                }
            })
            .catch(err => {
                updateStatus('Error: ' + err.message, 'error');
            });
        }

        // ===================== Settings =====================

        function updateSettings() {
            const simulations = parseInt(document.getElementById('sim-input').value);
            const cpuct = parseFloat(document.getElementById('cpuct-input').value);
            const riskBeta = parseFloat(document.getElementById('risk-beta-input').value);
            const statusEl = document.getElementById('settings-status');

            fetch('/api/update_settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ num_simulations: simulations, c_puct: cpuct, risk_beta: riskBeta })
            })
            .then(r => r.json())
            .then(data => {
                if (data.success) {
                    statusEl.textContent = `Updated: ${data.num_simulations} sims, c_puct=${data.c_puct}, beta=${data.risk_beta}`;
                    statusEl.style.color = '#27ae60';
                } else {
                    statusEl.textContent = 'Failed to update';
                    statusEl.style.color = '#e74c3c';
                }
                setTimeout(() => { statusEl.textContent = ''; }, 3000);
            })
            .catch(err => {
                statusEl.textContent = 'Error: ' + err.message;
                statusEl.style.color = '#e74c3c';
            });
        }

        // Speed slider live update
        document.getElementById('speed-slider').addEventListener('input', function() {
            document.getElementById('speed-value').textContent = this.value + 's';
        });

        // ===================== PGN Export =====================

        function exportPGN() {
            if (replayMode) {
                if (replayGame) {
                    const pgn = replayGame.pgn();
                    const ts = new Date().toISOString().replace(/[-:T]/g, '').slice(0, 15);
                    downloadPGN(pgn, `replay_game_${ts}.pgn`);
                }
                return;
            }

            fetch('/api/export_pgn', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ session_id: sessionId })
            })
            .then(r => r.json())
            .then(data => {
                if (!data.success) {
                    updateStatus('Export failed: ' + data.error, 'error');
                    return;
                }
                downloadPGN(data.pgn, data.filename);
                updateStatus('PGN exported!', 'success');
            })
            .catch(err => updateStatus('Export error: ' + err.message, 'error'));
        }

        function downloadPGN(content, filename) {
            const blob = new Blob([content], { type: 'application/x-chess-pgn' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ===================== PGN Import & Replay Mode =====================

        function importPGN(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) { loadPGNForReplay(e.target.result); };
            reader.readAsText(file);
            event.target.value = '';
        }

        function loadPGNForReplay(pgnText) {
            if (aiTurnActive) stopAI();

            const tempGame = new Chess();
            const loaded = tempGame.load_pgn(pgnText);
            if (!loaded) { updateStatus('Failed to parse PGN file', 'error'); return; }

            const moves = tempGame.history({ verbose: true });
            if (moves.length === 0) { updateStatus('PGN contains no moves', 'error'); return; }

            replayMode = true;
            replayGame = tempGame;
            replayMoves = moves;
            replayIndex = -1;

            document.getElementById('replay-controls').classList.add('active');

            game = new Chess();
            board.orientation('white');
            board.position('start');

            updateReplayMoveHistory();
            updateReplayInfo();
            updateStatus('Replay mode: Use navigation buttons to step through moves', 'info');
        }

        function replayStep(direction, fromAutoPlay) {
            if (!replayMode) return;
            if (!fromAutoPlay && replayAutoPlay) stopReplayAutoPlay();

            switch (direction) {
                case 'first': replayIndex = -1; break;
                case 'prev': if (replayIndex >= 0) replayIndex--; break;
                case 'next': if (replayIndex < replayMoves.length - 1) replayIndex++; break;
                case 'last': replayIndex = replayMoves.length - 1; break;
            }

            game = new Chess();
            for (let i = 0; i <= replayIndex; i++) game.move(replayMoves[i].san);
            board.position(game.fen(), true);
            updateReplayMoveHistory();
            updateReplayInfo();
        }

        function updateReplayInfo() {
            const el = document.getElementById('replay-info');
            if (replayIndex < 0) el.textContent = `Start position (${replayMoves.length} moves)`;
            else el.textContent = `Move ${replayIndex + 1} / ${replayMoves.length}`;
        }

        function updateReplayMoveHistory() {
            const el = document.getElementById('move-history');
            if (replayMoves.length === 0) { el.innerHTML = '<p style="color: #95a5a6;">No moves</p>'; return; }

            let html = '';
            for (let i = 0; i < replayMoves.length; i += 2) {
                const num = Math.floor(i / 2) + 1;
                const wc = (i === replayIndex) ? ' class="replay-active"' : '';
                const bc = (i + 1 === replayIndex) ? ' class="replay-active"' : '';
                html += `<p>${num}. <span${wc} onclick="jumpToMove(${i})" style="cursor:pointer">${replayMoves[i].san}</span>`;
                if (i + 1 < replayMoves.length) {
                    html += ` <span${bc} onclick="jumpToMove(${i + 1})" style="cursor:pointer">${replayMoves[i + 1].san}</span>`;
                }
                html += '</p>';
            }
            el.innerHTML = html;
            el.scrollTop = el.scrollHeight;
        }

        function jumpToMove(index) {
            if (!replayMode) return;
            if (replayAutoPlay) stopReplayAutoPlay();
            replayIndex = index;
            game = new Chess();
            for (let i = 0; i <= replayIndex; i++) game.move(replayMoves[i].san);
            board.position(game.fen(), true);
            updateReplayMoveHistory();
            updateReplayInfo();
        }

        function exitReplay() {
            if (replayAutoPlay) stopReplayAutoPlay();
            replayMode = false;
            replayGame = null;
            replayMoves = [];
            replayIndex = -1;
            document.getElementById('replay-controls').classList.remove('active');
            game = new Chess();
            board.position('start');
            moveHistory = [];
            updateMoveHistory();
            updateStatus('Replay ended. Set up a new game.', 'info');
        }

        // ===================== Replay Auto-Play =====================

        function toggleReplayAutoPlay() {
            if (replayAutoPlay) stopReplayAutoPlay();
            else startReplayAutoPlay();
        }

        function startReplayAutoPlay() {
            if (!replayMode || replayIndex >= replayMoves.length - 1) return;
            replayAutoPlay = true;
            const btn = document.getElementById('autoplay-btn');
            btn.classList.add('playing');
            btn.innerHTML = '&#9646;&#9646;';
            btn.title = 'Pause auto-play';
            replayAutoPlayStep();
        }

        function stopReplayAutoPlay() {
            replayAutoPlay = false;
            if (replayAutoPlayTimeout) { clearTimeout(replayAutoPlayTimeout); replayAutoPlayTimeout = null; }
            const btn = document.getElementById('autoplay-btn');
            btn.classList.remove('playing');
            btn.innerHTML = '&#9654;';
            btn.title = 'Auto-play';
        }

        function replayAutoPlayStep() {
            if (!replayAutoPlay || !replayMode || replayIndex >= replayMoves.length - 1) {
                stopReplayAutoPlay();
                return;
            }
            replayStep('next', true);
            const delay = parseFloat(document.getElementById('speed-slider').value) * 1000;
            replayAutoPlayTimeout = setTimeout(replayAutoPlayStep, delay);
        }

        // ===================== Keyboard Shortcuts =====================

        document.addEventListener('keydown', function(e) {
            if (!replayMode) return;
            switch (e.key) {
                case 'ArrowLeft': e.preventDefault(); replayStep('prev'); break;
                case 'ArrowRight': e.preventDefault(); replayStep('next'); break;
                case 'Home': e.preventDefault(); replayStep('first'); break;
                case 'End': e.preventDefault(); replayStep('last'); break;
                case 'Escape': e.preventDefault(); exitReplay(); break;
                case ' ': e.preventDefault(); toggleReplayAutoPlay(); break;
            }
        });

        // ===================== Board Initialization =====================

        const boardConfig = {
            draggable: true,
            position: 'start',
            onDragStart: onDragStart,
            onDrop: onDrop,
            onSnapEnd: onSnapEnd,
            pieceTheme: 'https://chessboardjs.com/img/chesspieces/wikipedia/{piece}.png'
        };
        board = Chessboard('board', boardConfig);

        $(window).resize(function() { board.resize(); });

        // Initialize setup panel on page load
        initSetupPanel();
    </script>
</body>
</html>
